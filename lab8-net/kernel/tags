!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARECORD	net.h	165;"	d
ARP_HRD_ETHER	net.h	132;"	d
ARP_OP_REPLY	net.h	/^  ARP_OP_REPLY = 2,   \/\/ replies a hw addr given protocol addr$/;"	e	enum:__anon1
ARP_OP_REQUEST	net.h	/^  ARP_OP_REQUEST = 1, \/\/ requests hw addr given protocol addr$/;"	e	enum:__anon1
BACKSPACE	console.c	25;"	d	file:
BBLOCK	fs.h	51;"	d
BPB	fs.h	48;"	d
BSIZE	fs.h	6;"	d
C	console.c	26;"	d	file:
CLINT	memlayout.h	33;"	d
CLINT_MTIME	memlayout.h	35;"	d
CLINT_MTIMECMP	memlayout.h	34;"	d
CONSOLE	file.h	47;"	d
DATA_MAX	e1000_dev.h	90;"	d
DIRSIZ	fs.h	54;"	d
E1000_CTL	e1000_dev.h	7;"	d
E1000_CTL_FRCDPLX	e1000_dev.h	30;"	d
E1000_CTL_FRCSPD	e1000_dev.h	29;"	d
E1000_CTL_RST	e1000_dev.h	31;"	d
E1000_CTL_SLU	e1000_dev.h	28;"	d
E1000_ICR	e1000_dev.h	8;"	d
E1000_IMS	e1000_dev.h	9;"	d
E1000_IRQ	memlayout.h	29;"	d
E1000_MTA	e1000_dev.h	24;"	d
E1000_RA	e1000_dev.h	25;"	d
E1000_RADV	e1000_dev.h	15;"	d
E1000_RCTL	e1000_dev.h	10;"	d
E1000_RCTL_BAM	e1000_dev.h	70;"	d
E1000_RCTL_BSEX	e1000_dev.h	85;"	d
E1000_RCTL_CFI	e1000_dev.h	82;"	d
E1000_RCTL_CFIEN	e1000_dev.h	81;"	d
E1000_RCTL_DPF	e1000_dev.h	83;"	d
E1000_RCTL_DTYP_MASK	e1000_dev.h	59;"	d
E1000_RCTL_DTYP_PS	e1000_dev.h	60;"	d
E1000_RCTL_EN	e1000_dev.h	50;"	d
E1000_RCTL_FLXBUF_MASK	e1000_dev.h	87;"	d
E1000_RCTL_FLXBUF_SHIFT	e1000_dev.h	88;"	d
E1000_RCTL_LBM_MAC	e1000_dev.h	56;"	d
E1000_RCTL_LBM_NO	e1000_dev.h	55;"	d
E1000_RCTL_LBM_SLP	e1000_dev.h	57;"	d
E1000_RCTL_LBM_TCVR	e1000_dev.h	58;"	d
E1000_RCTL_LPE	e1000_dev.h	54;"	d
E1000_RCTL_MDR	e1000_dev.h	69;"	d
E1000_RCTL_MO_0	e1000_dev.h	65;"	d
E1000_RCTL_MO_1	e1000_dev.h	66;"	d
E1000_RCTL_MO_2	e1000_dev.h	67;"	d
E1000_RCTL_MO_3	e1000_dev.h	68;"	d
E1000_RCTL_MO_SHIFT	e1000_dev.h	64;"	d
E1000_RCTL_MPE	e1000_dev.h	53;"	d
E1000_RCTL_PMCF	e1000_dev.h	84;"	d
E1000_RCTL_RDMTS_EIGTH	e1000_dev.h	63;"	d
E1000_RCTL_RDMTS_HALF	e1000_dev.h	61;"	d
E1000_RCTL_RDMTS_QUAT	e1000_dev.h	62;"	d
E1000_RCTL_RST	e1000_dev.h	49;"	d
E1000_RCTL_SBP	e1000_dev.h	51;"	d
E1000_RCTL_SECRC	e1000_dev.h	86;"	d
E1000_RCTL_SZ_1024	e1000_dev.h	73;"	d
E1000_RCTL_SZ_16384	e1000_dev.h	77;"	d
E1000_RCTL_SZ_2048	e1000_dev.h	72;"	d
E1000_RCTL_SZ_256	e1000_dev.h	75;"	d
E1000_RCTL_SZ_4096	e1000_dev.h	79;"	d
E1000_RCTL_SZ_512	e1000_dev.h	74;"	d
E1000_RCTL_SZ_8192	e1000_dev.h	78;"	d
E1000_RCTL_UPE	e1000_dev.h	52;"	d
E1000_RCTL_VFE	e1000_dev.h	80;"	d
E1000_RDBAL	e1000_dev.h	13;"	d
E1000_RDH	e1000_dev.h	16;"	d
E1000_RDLEN	e1000_dev.h	18;"	d
E1000_RDT	e1000_dev.h	17;"	d
E1000_RDTR	e1000_dev.h	14;"	d
E1000_RSRPD	e1000_dev.h	19;"	d
E1000_RXD_STAT_DD	e1000_dev.h	112;"	d
E1000_RXD_STAT_EOP	e1000_dev.h	113;"	d
E1000_TCTL	e1000_dev.h	11;"	d
E1000_TCTL_BCE	e1000_dev.h	36;"	d
E1000_TCTL_COLD	e1000_dev.h	40;"	d
E1000_TCTL_COLD_SHIFT	e1000_dev.h	41;"	d
E1000_TCTL_CT	e1000_dev.h	38;"	d
E1000_TCTL_CT_SHIFT	e1000_dev.h	39;"	d
E1000_TCTL_EN	e1000_dev.h	35;"	d
E1000_TCTL_MULR	e1000_dev.h	46;"	d
E1000_TCTL_NRTU	e1000_dev.h	45;"	d
E1000_TCTL_PBE	e1000_dev.h	43;"	d
E1000_TCTL_PSP	e1000_dev.h	37;"	d
E1000_TCTL_RST	e1000_dev.h	34;"	d
E1000_TCTL_RTLC	e1000_dev.h	44;"	d
E1000_TCTL_SWXOFF	e1000_dev.h	42;"	d
E1000_TDBAL	e1000_dev.h	20;"	d
E1000_TDH	e1000_dev.h	22;"	d
E1000_TDLEN	e1000_dev.h	21;"	d
E1000_TDT	e1000_dev.h	23;"	d
E1000_TIPG	e1000_dev.h	12;"	d
E1000_TXD_CMD_EOP	e1000_dev.h	93;"	d
E1000_TXD_CMD_RS	e1000_dev.h	94;"	d
E1000_TXD_STAT_DD	e1000_dev.h	97;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
ETHADDR_LEN	net.h	77;"	d
ETHTYPE_ARP	net.h	87;"	d
ETHTYPE_IP	net.h	86;"	d
FCR	uart.c	27;"	d	file:
FCR_FIFO_CLEAR	uart.c	29;"	d	file:
FCR_FIFO_ENABLE	uart.c	28;"	d	file:
FD_DEVICE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	e	enum:file::__anon5
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	e	enum:file::__anon5
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	e	enum:file::__anon5
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	e	enum:file::__anon5
FD_SOCK	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	e	enum:file::__anon5
FSMAGIC	fs.h	25;"	d
FSSIZE	param.h	12;"	d
IBLOCK	fs.h	45;"	d
IER	uart.c	24;"	d	file:
IER_RX_ENABLE	uart.c	25;"	d	file:
IER_TX_ENABLE	uart.c	26;"	d	file:
INPUT_BUF	console.c	48;"	d	file:
IPB	fs.h	42;"	d
IPPROTO_ICMP	net.h	102;"	d
IPPROTO_TCP	net.h	103;"	d
IPPROTO_UDP	net.h	104;"	d
ISR	uart.c	30;"	d	file:
KERNBASE	memlayout.h	51;"	d
KSTACK	memlayout.h	60;"	d
LCR	uart.c	31;"	d	file:
LCR_BAUD_LATCH	uart.c	33;"	d	file:
LCR_EIGHT_BITS	uart.c	32;"	d	file:
LOGSIZE	param.h	10;"	d
LSR	uart.c	34;"	d	file:
LSR_RX_READY	uart.c	35;"	d	file:
LSR_TX_IDLE	uart.c	36;"	d	file:
MAKE_IP_ADDR	net.h	106;"	d
MAKE_SATP	riscv.h	199;"	d
MAXARG	param.h	8;"	d
MAXFILE	fs.h	29;"	d
MAXOPBLOCKS	param.h	9;"	d
MAXPATH	param.h	13;"	d
MAXVA	riscv.h	363;"	d
MBUF_DEFAULT_HEADROOM	net.h	6;"	d
MBUF_SIZE	net.h	5;"	d
MIE_MEIE	riscv.h	97;"	d
MIE_MSIE	riscv.h	99;"	d
MIE_MTIE	riscv.h	98;"	d
MSTATUS_MIE	riscv.h	16;"	d
MSTATUS_MPP_M	riscv.h	13;"	d
MSTATUS_MPP_MASK	riscv.h	12;"	d
MSTATUS_MPP_S	riscv.h	14;"	d
MSTATUS_MPP_U	riscv.h	15;"	d
NBUF	param.h	11;"	d
NCPU	param.h	2;"	d
NDEV	param.h	6;"	d
NDIRECT	fs.h	27;"	d
NELEM	defs.h	195;"	d
NFILE	param.h	4;"	d
NINDIRECT	fs.h	28;"	d
NINODE	param.h	5;"	d
NLOCK	spinlock.c	12;"	d	file:
NOFILE	param.h	3;"	d
NPROC	param.h	1;"	d
NUM	virtio.h	48;"	d
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_TRUNC	fcntl.h	5;"	d
O_WRONLY	fcntl.h	2;"	d
PA2PTE	riscv.h	348;"	d
PGROUNDDOWN	riscv.h	339;"	d
PGROUNDUP	riscv.h	338;"	d
PGSHIFT	riscv.h	336;"	d
PGSIZE	riscv.h	335;"	d
PHYSTOP	memlayout.h	52;"	d
PIPESIZE	pipe.c	11;"	d	file:
PLIC	memlayout.h	38;"	d
PLIC_MCLAIM	memlayout.h	45;"	d
PLIC_MENABLE	memlayout.h	41;"	d
PLIC_MPRIORITY	memlayout.h	43;"	d
PLIC_PENDING	memlayout.h	40;"	d
PLIC_PRIORITY	memlayout.h	39;"	d
PLIC_SCLAIM	memlayout.h	46;"	d
PLIC_SENABLE	memlayout.h	42;"	d
PLIC_SPRIORITY	memlayout.h	44;"	d
PTE2PA	riscv.h	350;"	d
PTE_FLAGS	riscv.h	352;"	d
PTE_R	riscv.h	342;"	d
PTE_U	riscv.h	345;"	d
PTE_V	riscv.h	341;"	d
PTE_W	riscv.h	343;"	d
PTE_X	riscv.h	344;"	d
PX	riscv.h	357;"	d
PXMASK	riscv.h	355;"	d
PXSHIFT	riscv.h	356;"	d
QCLASS	net.h	166;"	d
R	virtio_disk.c	21;"	d	file:
RHR	uart.c	22;"	d	file:
ROOTDEV	param.h	7;"	d
ROOTINO	fs.h	5;"	d
RUNNABLE	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RX_RING_SIZE	e1000.c	15;"	d	file:
ReadReg	uart.c	38;"	d	file:
Reg	uart.c	16;"	d	file:
SATP_SV39	riscv.h	197;"	d
SIE_SEIE	riscv.h	79;"	d
SIE_SSIE	riscv.h	81;"	d
SIE_STIE	riscv.h	80;"	d
SLEEPING	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SSTATUS_SIE	riscv.h	46;"	d
SSTATUS_SPIE	riscv.h	44;"	d
SSTATUS_SPP	riscv.h	43;"	d
SSTATUS_UIE	riscv.h	47;"	d
SSTATUS_UPIE	riscv.h	45;"	d
STATS	file.h	48;"	d
SYS_chdir	syscall.h	10;"	d
SYS_close	syscall.h	22;"	d
SYS_connect	syscall.h	32;"	d
SYS_dup	syscall.h	11;"	d
SYS_exec	syscall.h	8;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	9;"	d
SYS_getpid	syscall.h	12;"	d
SYS_kill	syscall.h	7;"	d
SYS_link	syscall.h	20;"	d
SYS_mkdir	syscall.h	21;"	d
SYS_mknod	syscall.h	18;"	d
SYS_mmap	syscall.h	30;"	d
SYS_munmap	syscall.h	31;"	d
SYS_open	syscall.h	16;"	d
SYS_pgaccess	syscall.h	33;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	6;"	d
SYS_sbrk	syscall.h	13;"	d
SYS_sigalarm	syscall.h	27;"	d
SYS_sigreturn	syscall.h	28;"	d
SYS_sleep	syscall.h	14;"	d
SYS_symlink	syscall.h	29;"	d
SYS_sysinfo	syscall.h	26;"	d
SYS_trace	syscall.h	25;"	d
SYS_unlink	syscall.h	19;"	d
SYS_uptime	syscall.h	15;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	syscall.h	17;"	d
THR	uart.c	23;"	d	file:
TRAMPOLINE	memlayout.h	56;"	d
TRAPFRAME	memlayout.h	72;"	d
TX_RING_SIZE	e1000.c	11;"	d	file:
T_DEVICE	stat.h	3;"	d
T_DIR	stat.h	1;"	d
T_FILE	stat.h	2;"	d
UART0	memlayout.h	21;"	d
UART0_IRQ	memlayout.h	22;"	d
UART_TX_BUF_SIZE	uart.c	43;"	d	file:
UNUSED	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
USED	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
USYSCALL	memlayout.h	74;"	d
VIRTIO0	memlayout.h	25;"	d
VIRTIO0_IRQ	memlayout.h	26;"	d
VIRTIO_BLK_F_CONFIG_WCE	virtio.h	40;"	d
VIRTIO_BLK_F_MQ	virtio.h	41;"	d
VIRTIO_BLK_F_RO	virtio.h	38;"	d
VIRTIO_BLK_F_SCSI	virtio.h	39;"	d
VIRTIO_BLK_T_IN	virtio.h	84;"	d
VIRTIO_BLK_T_OUT	virtio.h	85;"	d
VIRTIO_CONFIG_S_ACKNOWLEDGE	virtio.h	32;"	d
VIRTIO_CONFIG_S_DRIVER	virtio.h	33;"	d
VIRTIO_CONFIG_S_DRIVER_OK	virtio.h	34;"	d
VIRTIO_CONFIG_S_FEATURES_OK	virtio.h	35;"	d
VIRTIO_F_ANY_LAYOUT	virtio.h	42;"	d
VIRTIO_MMIO_DEVICE_FEATURES	virtio.h	17;"	d
VIRTIO_MMIO_DEVICE_ID	virtio.h	15;"	d
VIRTIO_MMIO_DRIVER_FEATURES	virtio.h	18;"	d
VIRTIO_MMIO_GUEST_PAGE_SIZE	virtio.h	19;"	d
VIRTIO_MMIO_INTERRUPT_ACK	virtio.h	28;"	d
VIRTIO_MMIO_INTERRUPT_STATUS	virtio.h	27;"	d
VIRTIO_MMIO_MAGIC_VALUE	virtio.h	13;"	d
VIRTIO_MMIO_QUEUE_ALIGN	virtio.h	23;"	d
VIRTIO_MMIO_QUEUE_NOTIFY	virtio.h	26;"	d
VIRTIO_MMIO_QUEUE_NUM	virtio.h	22;"	d
VIRTIO_MMIO_QUEUE_NUM_MAX	virtio.h	21;"	d
VIRTIO_MMIO_QUEUE_PFN	virtio.h	24;"	d
VIRTIO_MMIO_QUEUE_READY	virtio.h	25;"	d
VIRTIO_MMIO_QUEUE_SEL	virtio.h	20;"	d
VIRTIO_MMIO_STATUS	virtio.h	29;"	d
VIRTIO_MMIO_VENDOR_ID	virtio.h	16;"	d
VIRTIO_MMIO_VERSION	virtio.h	14;"	d
VIRTIO_RING_F_EVENT_IDX	virtio.h	44;"	d
VIRTIO_RING_F_INDIRECT_DESC	virtio.h	43;"	d
VRING_DESC_F_NEXT	virtio.h	57;"	d
VRING_DESC_F_WRITE	virtio.h	58;"	d
WriteReg	uart.c	39;"	d	file:
ZOMBIE	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
_entry	entry.S	/^_entry:$/;"	l
a0	proc.h	/^  \/* 112 *\/ uint64 a0;$/;"	m	struct:trapframe
a1	proc.h	/^  \/* 120 *\/ uint64 a1;$/;"	m	struct:trapframe
a2	proc.h	/^  \/* 128 *\/ uint64 a2;$/;"	m	struct:trapframe
a3	proc.h	/^  \/* 136 *\/ uint64 a3;$/;"	m	struct:trapframe
a4	proc.h	/^  \/* 144 *\/ uint64 a4;$/;"	m	struct:trapframe
a5	proc.h	/^  \/* 152 *\/ uint64 a5;$/;"	m	struct:trapframe
a6	proc.h	/^  \/* 160 *\/ uint64 a6;$/;"	m	struct:trapframe
a7	proc.h	/^  \/* 168 *\/ uint64 a7;$/;"	m	struct:trapframe
aa	net.h	/^  uint8 aa: 1;  \/\/ authoritive$/;"	m	struct:dns
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
acquiresleep	sleeplock.c	/^acquiresleep(struct sleeplock *lk)$/;"	f
ad	net.h	/^  uint8 ad: 1;  \/\/ authenticated data$/;"	m	struct:dns
addr	e1000_dev.h	/^  uint64 addr;       \/* Address of the descriptor's data buffer *\/$/;"	m	struct:rx_desc
addr	e1000_dev.h	/^  uint64 addr;$/;"	m	struct:tx_desc
addr	virtio.h	/^  uint64 addr;$/;"	m	struct:virtq_desc
addrs	file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode
addrs	fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode
align	elf.h	/^  uint64 align;$/;"	m	struct:proghdr
alloc3_desc	virtio_disk.c	/^alloc3_desc(int *idx)$/;"	f	file:
alloc_desc	virtio_disk.c	/^alloc_desc()$/;"	f	file:
allocpid	proc.c	/^allocpid() {$/;"	f
allocproc	proc.c	/^allocproc(void)$/;"	f	file:
ancount	net.h	/^  uint16 ancount; \/\/ number of resource records in answer section$/;"	m	struct:dns
arcount	net.h	/^  uint16 arcount; \/\/ number of resource records in additional records$/;"	m	struct:dns
argaddr	syscall.c	/^argaddr(int n, uint64 *ip)$/;"	f
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	syscall.c	/^argint(int n, int *ip)$/;"	f
argraw	syscall.c	/^argraw(int n)$/;"	f	file:
argstr	syscall.c	/^argstr(int n, char *buf, int max)$/;"	f
arp	net.h	/^struct arp {$/;"	s
avail	virtio_disk.c	/^  struct virtq_avail *avail;$/;"	m	struct:disk	typeref:struct:disk::virtq_avail	file:
b	virtio_disk.c	/^    struct buf *b;$/;"	m	struct:disk::__anon9	typeref:struct:disk::__anon9::buf	file:
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon6
begin_op	log.c	/^begin_op(void)$/;"	f
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	bio.c	/^bget(uint dev, uint blockno)$/;"	f	file:
binit	bio.c	/^binit(void)$/;"	f
block	log.c	/^  int block[LOGSIZE];$/;"	m	struct:logheader	file:
blockno	buf.h	/^  uint blockno;$/;"	m	struct:buf
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bmapstart	fs.h	/^  uint bmapstart;    \/\/ Block number of first free map block$/;"	m	struct:superblock
bpin	bio.c	/^bpin(struct buf *b) {$/;"	f
bread	bio.c	/^bread(uint dev, uint blockno)$/;"	f
brelse	bio.c	/^brelse(struct buf *b)$/;"	f
broadcast_mac	net.c	/^static uint8 broadcast_mac[ETHADDR_LEN] = { 0xFF, 0XFF, 0XFF, 0XFF, 0XFF, 0XFF };$/;"	v	file:
bswapl	net.h	/^static inline uint32 bswapl(uint32 val)$/;"	f
bswaps	net.h	/^static inline uint16 bswaps(uint16 val)$/;"	f
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon6	typeref:struct:__anon6::buf	file:
buf	buf.h	/^struct buf {$/;"	s
buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon4	file:
buf	net.h	/^  char         buf[MBUF_SIZE]; \/\/ the backing store$/;"	m	struct:mbuf
bunpin	bio.c	/^bunpin(struct buf *b) {$/;"	f
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:
cd	net.h	/^  uint8 cd: 1;  \/\/ checking disabled$/;"	m	struct:dns
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
clockintr	trap.c	/^clockintr()$/;"	f
cmd	e1000_dev.h	/^  uint8 cmd;$/;"	m	struct:tx_desc
commit	log.c	/^commit()$/;"	f	file:
committing	log.c	/^  int committing;  \/\/ in commit(), please wait.$/;"	m	struct:log	file:
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon4
consoleinit	console.c	/^consoleinit(void)$/;"	f
consoleintr	console.c	/^consoleintr(int c)$/;"	f
consoleread	console.c	/^consoleread(int user_dst, uint64 dst, int n)$/;"	f
consolewrite	console.c	/^consolewrite(int user_src, uint64 src, int n)$/;"	f
consputc	console.c	/^consputc(int c)$/;"	f
context	proc.h	/^  struct context context;      \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	/^  struct context context;     \/\/ swtch() here to enter scheduler().$/;"	m	struct:cpu	typeref:struct:cpu::context
context	proc.h	/^struct context {$/;"	s
copyin	vm.c	/^copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)$/;"	f
copyinstr	vm.c	/^copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)$/;"	f
copyout	vm.c	/^copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)$/;"	f
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu
cpuid	proc.c	/^cpuid()$/;"	f
cpus	proc.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
cso	e1000_dev.h	/^  uint8 cso;$/;"	m	struct:tx_desc
css	e1000_dev.h	/^  uint8 css;$/;"	m	struct:tx_desc
csum	e1000_dev.h	/^  uint16 csum;       \/* Packet checksum *\/$/;"	m	struct:rx_desc
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
data	buf.h	/^  uchar data[BSIZE];$/;"	m	struct:buf
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
day	date.h	/^  uint day;$/;"	m	struct:rtcdate
desc	virtio_disk.c	/^  struct virtq_desc *desc;$/;"	m	struct:disk	typeref:struct:disk::virtq_desc	file:
dev	buf.h	/^  uint dev;$/;"	m	struct:buf
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	log.c	/^  int dev;$/;"	m	struct:log	file:
dev	stat.h	/^  int dev;     \/\/ File system's disk device$/;"	m	struct:stat
devintr	trap.c	/^devintr()$/;"	f
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	file.h	/^struct devsw {$/;"	s
dhost	net.h	/^  uint8  dhost[ETHADDR_LEN];$/;"	m	struct:eth
digits	printf.c	/^static char digits[] = "0123456789abcdef";$/;"	v	file:
dinode	fs.h	/^struct dinode {$/;"	s
dirent	fs.h	/^struct dirent {$/;"	s
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
disk	buf.h	/^  int disk;    \/\/ does disk "own" buf?$/;"	m	struct:buf
disk	virtio_disk.c	/^static struct disk {$/;"	s	file:
disk	virtio_disk.c	/^} __attribute__ ((aligned (PGSIZE))) disk;$/;"	v	typeref:struct:disk	file:
dns	net.h	/^struct dns {$/;"	s
dns_data	net.h	/^struct dns_data {$/;"	s
dns_question	net.h	/^struct dns_question {$/;"	s
dport	net.h	/^  uint16 dport; \/\/ destination port$/;"	m	struct:udp
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon4	file:
e1000_init	e1000.c	/^e1000_init(uint32 *xregs)$/;"	f
e1000_intr	e1000.c	/^e1000_intr(void)$/;"	f
e1000_lock	e1000.c	/^struct spinlock e1000_lock;$/;"	v	typeref:struct:spinlock
e1000_recv	e1000.c	/^e1000_recv(void)$/;"	f	file:
e1000_transmit	e1000.c	/^e1000_transmit(struct mbuf *m)$/;"	f
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
either_copyin	proc.c	/^either_copyin(void *dst, int user_src, uint64 src, uint64 len)$/;"	f
either_copyout	proc.c	/^either_copyout(int user_dst, uint64 dst, void *src, uint64 len)$/;"	f
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elfhdr	elf.h	/^struct elfhdr {$/;"	s
end_op	log.c	/^end_op(void)$/;"	f
entry	elf.h	/^  uint64 entry;$/;"	m	struct:elfhdr
epc	proc.h	/^  \/*  24 *\/ uint64 epc;           \/\/ saved user program counter$/;"	m	struct:trapframe
errors	e1000_dev.h	/^  uint8 errors;      \/* Descriptor Errors *\/$/;"	m	struct:rx_desc
eth	net.h	/^struct eth {$/;"	s
exec	exec.c	/^exec(char *path, char **argv)$/;"	f
exit	proc.c	/^exit(int status)$/;"	f
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fetchaddr	syscall.c	/^fetchaddr(uint64 addr, uint64 *ip)$/;"	f
fetchstr	syscall.c	/^fetchstr(uint64 addr, char *buf, int max)$/;"	f
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon8	typeref:struct:__anon8::file	file:
file	file.h	/^struct file {$/;"	s
filealloc	file.c	/^filealloc(void)$/;"	f
fileclose	file.c	/^fileclose(struct file *f)$/;"	f
filedup	file.c	/^filedup(struct file *f)$/;"	f
fileinit	file.c	/^fileinit(void)$/;"	f
fileread	file.c	/^fileread(struct file *f, uint64 addr, int n)$/;"	f
filestat	file.c	/^filestat(struct file *f, uint64 addr)$/;"	f
filesz	elf.h	/^  uint64 filesz;$/;"	m	struct:proghdr
filewrite	file.c	/^filewrite(struct file *f, uint64 addr, int n)$/;"	f
findslot	spinlock.c	/^findslot(struct spinlock *lk) {$/;"	f	file:
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	elf.h	/^  uint32 flags;$/;"	m	struct:proghdr
flags	virtio.h	/^  uint16 flags; \/\/ always zero$/;"	m	struct:virtq_avail
flags	virtio.h	/^  uint16 flags; \/\/ always zero$/;"	m	struct:virtq_used
flags	virtio.h	/^  uint16 flags;$/;"	m	struct:virtq_desc
fork	proc.c	/^fork(void)$/;"	f
forkret	proc.c	/^forkret(void)$/;"	f
free	virtio_disk.c	/^  char free[NUM];  \/\/ is a descriptor free?$/;"	m	struct:disk	file:
free_chain	virtio_disk.c	/^free_chain(int i)$/;"	f	file:
free_desc	virtio_disk.c	/^free_desc(int i)$/;"	f	file:
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon7	typeref:struct:__anon7::run	file:
freelock	spinlock.c	/^freelock(struct spinlock *lk)$/;"	f
freeproc	proc.c	/^freeproc(struct proc *p)$/;"	f	file:
freerange	kalloc.c	/^freerange(void *pa_start, void *pa_end)$/;"	f
freewalk	vm.c	/^freewalk(pagetable_t pagetable)$/;"	f
fsinit	fs.c	/^fsinit(int dev) {$/;"	f
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anon8
gp	proc.h	/^  \/*  56 *\/ uint64 gp;$/;"	m	struct:trapframe
growproc	proc.c	/^growproc(int n)$/;"	f
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon6	typeref:struct:__anon6::buf	file:
head	net.h	/^  char         *head; \/\/ the current start position of the buffer$/;"	m	struct:mbuf
head	net.h	/^  struct mbuf *head;  \/\/ the first element in the queue$/;"	m	struct:mbufq	typeref:struct:mbufq::mbuf
hln	net.h	/^  uint8  hln; \/\/ length of hardware address$/;"	m	struct:arp
holding	spinlock.c	/^holding(struct spinlock *lk)$/;"	f
holdingsleep	sleeplock.c	/^holdingsleep(struct sleeplock *lk)$/;"	f
hour	date.h	/^  uint hour;$/;"	m	struct:rtcdate
hrd	net.h	/^  uint16 hrd; \/\/ format of hardware address$/;"	m	struct:arp
htonl	net.h	70;"	d
htons	net.h	69;"	d
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f
id	net.h	/^  uint16 id;  \/\/ request ID$/;"	m	struct:dns
id	virtio.h	/^  uint32 id;   \/\/ index of start of completed descriptor chain$/;"	m	struct:virtq_used_elem
idup	fs.c	/^idup(struct inode *ip)$/;"	f
idx	virtio.h	/^  uint16 idx;   \/\/ device increments when it adds a ring[] entry$/;"	m	struct:virtq_used
idx	virtio.h	/^  uint16 idx;   \/\/ driver will write ring[idx] next$/;"	m	struct:virtq_avail
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	fs.c	/^iinit()$/;"	f
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f
in_cksum	net.c	/^in_cksum(const unsigned char *addr, int len)$/;"	f	file:
info	virtio_disk.c	/^  } info[NUM];$/;"	m	struct:disk	typeref:struct:disk::__anon9	file:
initcode	proc.c	/^uchar initcode[] = {$/;"	v
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlog	log.c	/^initlog(int dev, struct superblock *sb)$/;"	f
initproc	proc.c	/^struct proc *initproc;$/;"	v	typeref:struct:proc
initsleeplock	sleeplock.c	/^initsleeplock(struct sleeplock *lk, char *name)$/;"	f
ino	stat.h	/^  uint ino;    \/\/ Inode number$/;"	m	struct:stat
inode	file.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon2	typeref:struct:__anon2::inode	file:
inodestart	fs.h	/^  uint inodestart;   \/\/ Block number of first inode block$/;"	m	struct:superblock
install_trans	log.c	/^install_trans(int recovering)$/;"	f	file:
intena	proc.h	/^  int intena;                 \/\/ Were interrupts enabled before push_off()?$/;"	m	struct:cpu
intr_get	riscv.h	/^intr_get()$/;"	f
intr_off	riscv.h	/^intr_off()$/;"	f
intr_on	riscv.h	/^intr_on()$/;"	f
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent
ip	file.h	/^  struct inode *ip;  \/\/ FD_INODE and FD_DEVICE$/;"	m	struct:file	typeref:struct:file::inode
ip	net.h	/^struct ip {$/;"	s
ip_dst	net.h	/^  uint32 ip_src, ip_dst;$/;"	m	struct:ip
ip_id	net.h	/^  uint16 ip_id;  \/\/ identification$/;"	m	struct:ip
ip_len	net.h	/^  uint16 ip_len; \/\/ total length$/;"	m	struct:ip
ip_off	net.h	/^  uint16 ip_off; \/\/ fragment offset field$/;"	m	struct:ip
ip_p	net.h	/^  uint8  ip_p;   \/\/ protocol$/;"	m	struct:ip
ip_src	net.h	/^  uint32 ip_src, ip_dst;$/;"	m	struct:ip
ip_sum	net.h	/^  uint16 ip_sum; \/\/ checksum$/;"	m	struct:ip
ip_tos	net.h	/^  uint8  ip_tos; \/\/ type of service$/;"	m	struct:ip
ip_ttl	net.h	/^  uint8  ip_ttl; \/\/ time to live$/;"	m	struct:ip
ip_vhl	net.h	/^  uint8  ip_vhl; \/\/ version << 4 | header length >> 2$/;"	m	struct:ip
iput	fs.c	/^iput(struct inode *ip)$/;"	f
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
itable	fs.c	/^} itable;$/;"	v	typeref:struct:__anon2
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f
kalloc	kalloc.c	/^kalloc(void)$/;"	f
kernel_hartid	proc.h	/^  \/*  32 *\/ uint64 kernel_hartid; \/\/ saved kernel tp$/;"	m	struct:trapframe
kernel_pagetable	vm.c	/^pagetable_t kernel_pagetable;$/;"	v
kernel_satp	proc.h	/^  \/*   0 *\/ uint64 kernel_satp;   \/\/ kernel page table$/;"	m	struct:trapframe
kernel_sp	proc.h	/^  \/*   8 *\/ uint64 kernel_sp;     \/\/ top of process's kernel stack$/;"	m	struct:trapframe
kernel_trap	proc.h	/^  \/*  16 *\/ uint64 kernel_trap;   \/\/ usertrap()$/;"	m	struct:trapframe
kerneltrap	trap.c	/^kerneltrap()$/;"	f
kernelvec	kernelvec.S	/^kernelvec:$/;"	l
kfree	kalloc.c	/^kfree(void *pa)$/;"	f
kill	proc.c	/^kill(int pid)$/;"	f
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc
kinit	kalloc.c	/^kinit()$/;"	f
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon7
kstack	proc.h	/^  uint64 kstack;               \/\/ Virtual address of kernel stack$/;"	m	struct:proc
kvminit	vm.c	/^kvminit(void)$/;"	f
kvminithart	vm.c	/^kvminithart()$/;"	f
kvmmake	vm.c	/^kvmmake(void)$/;"	f
kvmmap	vm.c	/^kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)$/;"	f
len	net.h	/^  uint16 len;$/;"	m	struct:dns_data
len	net.h	/^  unsigned int len;   \/\/ the length of the buffer$/;"	m	struct:mbuf
len	virtio.h	/^  uint32 len;$/;"	m	struct:virtq_desc
len	virtio.h	/^  uint32 len;$/;"	m	struct:virtq_used_elem
length	e1000_dev.h	/^  uint16 length;     \/* Length of data DMAed into data buffer *\/$/;"	m	struct:rx_desc
length	e1000_dev.h	/^  uint16 length;$/;"	m	struct:tx_desc
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
lk	sleeplock.h	/^  struct spinlock lk; \/\/ spinlock protecting this sleep lock$/;"	m	struct:sleeplock	typeref:struct:sleeplock::spinlock
loadseg	exec.c	/^loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz)$/;"	f	file:
local_ip	net.c	/^static uint32 local_ip = MAKE_IP_ADDR(10, 0, 2, 15); \/\/ qemu's idea of the guest IP$/;"	v	file:
local_mac	net.c	/^static uint8 local_mac[ETHADDR_LEN] = { 0x52, 0x54, 0x00, 0x12, 0x34, 0x56 };$/;"	v	file:
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon6	typeref:struct:__anon6::spinlock	file:
lock	buf.h	/^  struct sleeplock lock;$/;"	m	struct:buf	typeref:struct:buf::sleeplock
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon8	typeref:struct:__anon8::spinlock	file:
lock	file.h	/^  struct sleeplock lock; \/\/ protects everything below here$/;"	m	struct:inode	typeref:struct:inode::sleeplock
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon7	typeref:struct:__anon7::spinlock	file:
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	printf.c	/^  struct spinlock lock;$/;"	m	struct:__anon3	typeref:struct:__anon3::spinlock	file:
lock	proc.h	/^  struct spinlock lock;$/;"	m	struct:proc	typeref:struct:proc::spinlock
lock	sysnet.c	/^  struct spinlock lock; \/\/ protects the rxq$/;"	m	struct:sock	typeref:struct:sock::spinlock	file:
lock	sysnet.c	/^static struct spinlock lock;$/;"	v	typeref:struct:spinlock	file:
lock_locks	spinlock.c	/^struct spinlock lock_locks;$/;"	v	typeref:struct:spinlock
locked	sleeplock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:sleeplock
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock
lockfree_read4	spinlock.c	/^lockfree_read4(int *addr) {$/;"	f
lockfree_read8	spinlock.c	/^lockfree_read8(uint64 *addr) {$/;"	f
locking	printf.c	/^  int locking;$/;"	m	struct:__anon3	file:
locks	spinlock.c	/^static struct spinlock *locks[NLOCK];$/;"	v	typeref:struct:spinlock	file:
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log_write	log.c	/^log_write(struct buf *b)$/;"	f
logheader	log.c	/^struct logheader {$/;"	s	file:
logstart	fs.h	/^  uint logstart;     \/\/ Block number of first log block$/;"	m	struct:superblock
lport	sysnet.c	/^  uint16 lport;      \/\/ the local UDP port number$/;"	m	struct:sock	file:
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
magic	fs.h	/^  uint magic;        \/\/ Must be FSMAGIC$/;"	m	struct:superblock
main	main.c	/^main()$/;"	f
major	file.h	/^  short major;       \/\/ FD_DEVICE$/;"	m	struct:file
major	file.h	/^  short major;$/;"	m	struct:inode
major	file.h	19;"	d
major	fs.h	/^  short major;          \/\/ Major device number (T_DEVICE only)$/;"	m	struct:dinode
mappages	vm.c	/^mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)$/;"	f
mbuf	net.h	/^struct mbuf {$/;"	s
mbufalloc	net.c	/^mbufalloc(unsigned int headroom)$/;"	f
mbuffree	net.c	/^mbuffree(struct mbuf *m)$/;"	f
mbufpull	net.c	/^mbufpull(struct mbuf *m, unsigned int len)$/;"	f
mbufpullhdr	net.h	28;"	d
mbufpush	net.c	/^mbufpush(struct mbuf *m, unsigned int len)$/;"	f
mbufpushhdr	net.h	29;"	d
mbufput	net.c	/^mbufput(struct mbuf *m, unsigned int len)$/;"	f
mbufputhdr	net.h	30;"	d
mbufq	net.h	/^struct mbufq {$/;"	s
mbufq_empty	net.c	/^mbufq_empty(struct mbufq *q)$/;"	f
mbufq_init	net.c	/^mbufq_init(struct mbufq *q)$/;"	f
mbufq_pophead	net.c	/^mbufq_pophead(struct mbufq *q)$/;"	f
mbufq_pushtail	net.c	/^mbufq_pushtail(struct mbufq *q, struct mbuf *m)$/;"	f
mbuftrim	net.c	/^mbuftrim(struct mbuf *m, unsigned int len)$/;"	f
mbuftrimhdr	net.h	31;"	d
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f
memsz	elf.h	/^  uint64 memsz;$/;"	m	struct:proghdr
min	fs.c	24;"	d	file:
minor	file.h	/^  short minor;$/;"	m	struct:inode
minor	file.h	20;"	d
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEVICE only)$/;"	m	struct:dinode
minute	date.h	/^  uint minute;$/;"	m	struct:rtcdate
mkdev	file.h	21;"	d
month	date.h	/^  uint month;$/;"	m	struct:rtcdate
mycpu	proc.c	/^mycpu(void) {$/;"	f
myproc	proc.c	/^myproc(void) {$/;"	f
n	log.c	/^  int n;$/;"	m	struct:logheader	file:
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc
name	sleeplock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:sleeplock
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	fs.c	/^namei(char *path)$/;"	f
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
net_rx	net.c	/^void net_rx(struct mbuf *m)$/;"	f
net_rx_arp	net.c	/^net_rx_arp(struct mbuf *m)$/;"	f	file:
net_rx_ip	net.c	/^net_rx_ip(struct mbuf *m)$/;"	f	file:
net_rx_udp	net.c	/^net_rx_udp(struct mbuf *m, uint16 len, struct ip *iphdr)$/;"	f	file:
net_tx_arp	net.c	/^net_tx_arp(uint16 op, uint8 dmac[ETHADDR_LEN], uint32 dip)$/;"	f	file:
net_tx_eth	net.c	/^net_tx_eth(struct mbuf *m, uint16 ethtype)$/;"	f	file:
net_tx_ip	net.c	/^net_tx_ip(struct mbuf *m, uint8 proto, uint32 dip)$/;"	f	file:
net_tx_udp	net.c	/^net_tx_udp(struct mbuf *m, uint32 dip,$/;"	f
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
next	net.h	/^  struct mbuf  *next; \/\/ the next mbuf in the chain$/;"	m	struct:mbuf	typeref:struct:mbuf::mbuf
next	sysnet.c	/^  struct sock *next; \/\/ the next socket in the list$/;"	m	struct:sock	typeref:struct:sock::sock	file:
next	virtio.h	/^  uint16 next;$/;"	m	struct:virtq_desc
nextpid	proc.c	/^int nextpid = 1;$/;"	v
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
nlink	file.h	/^  short nlink;$/;"	m	struct:inode
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock
noff	proc.h	/^  int noff;                   \/\/ Depth of push_off() nesting.$/;"	m	struct:cpu
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nscount	net.h	/^  uint16 nscount; \/\/ number of NS resource records in authority section$/;"	m	struct:dns
ntohl	net.h	68;"	d
ntohs	net.h	67;"	d
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
off	elf.h	/^  uint64 off;$/;"	m	struct:proghdr
off	file.h	/^  uint off;          \/\/ FD_INODE$/;"	m	struct:file
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
op	net.h	/^  uint16 op;  \/\/ operation$/;"	m	struct:arp
opcode	net.h	/^  uint8 opcode: 4; $/;"	m	struct:dns
ops	virtio_disk.c	/^  struct virtio_blk_req ops[NUM];$/;"	m	struct:disk	typeref:struct:disk::virtio_blk_req	file:
outstanding	log.c	/^  int outstanding; \/\/ how many FS sys calls are executing.$/;"	m	struct:log	file:
paddr	elf.h	/^  uint64 paddr;$/;"	m	struct:proghdr
pages	virtio_disk.c	/^  char pages[2*PGSIZE];$/;"	m	struct:disk	file:
pagetable	proc.h	/^  pagetable_t pagetable;       \/\/ User page table$/;"	m	struct:proc
pagetable_t	riscv.h	/^typedef uint64 *pagetable_t; \/\/ 512 PTEs$/;"	t
panic	printf.c	/^panic(char *s)$/;"	f
panicked	printf.c	/^volatile int panicked = 0;$/;"	v
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
pci_init	pci.c	/^pci_init()$/;"	f
pde_t	types.h	/^typedef uint64 pde_t;$/;"	t
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phoff	elf.h	/^  uint64 phoff;$/;"	m	struct:elfhdr
pid	memlayout.h	/^  int pid;  \/\/ Process ID$/;"	m	struct:usyscall
pid	proc.h	/^  int pid;                     \/\/ Process ID$/;"	m	struct:proc
pid	sleeplock.h	/^  int pid;           \/\/ Process holding lock$/;"	m	struct:sleeplock
pid_lock	proc.c	/^struct spinlock pid_lock;$/;"	v	typeref:struct:spinlock
pipe	file.h	/^  struct pipe *pipe; \/\/ FD_PIPE$/;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	pipe.c	/^pipeclose(struct pipe *pi, int writable)$/;"	f
piperead	pipe.c	/^piperead(struct pipe *pi, uint64 addr, int n)$/;"	f
pipewrite	pipe.c	/^pipewrite(struct pipe *pi, uint64 addr, int n)$/;"	f
plic_claim	plic.c	/^plic_claim(void)$/;"	f
plic_complete	plic.c	/^plic_complete(int irq)$/;"	f
plicinit	plic.c	/^plicinit(void)$/;"	f
plicinithart	plic.c	/^plicinithart(void)$/;"	f
pln	net.h	/^  uint8  pln; \/\/ length of protocol address$/;"	m	struct:arp
pop_off	spinlock.c	/^pop_off(void)$/;"	f
pr	printf.c	/^} pr;$/;"	v	typeref:struct:__anon3	file:
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
printf	printf.c	/^printf(char *fmt, ...)$/;"	f
printfinit	printf.c	/^printfinit(void)$/;"	f
printint	printf.c	/^printint(int xx, int base, int sign)$/;"	f	file:
printptr	printf.c	/^printptr(uint64 x)$/;"	f	file:
pro	net.h	/^  uint16 pro; \/\/ format of protocol address$/;"	m	struct:arp
proc	proc.c	/^struct proc proc[NPROC];$/;"	v	typeref:struct:proc
proc	proc.h	/^  struct proc *proc;          \/\/ The process running on this cpu, or null.$/;"	m	struct:cpu	typeref:struct:cpu::proc
proc	proc.h	/^struct proc {$/;"	s
proc_freepagetable	proc.c	/^proc_freepagetable(pagetable_t pagetable, uint64 sz)$/;"	f
proc_mapstacks	proc.c	/^proc_mapstacks(pagetable_t kpgtbl) {$/;"	f
proc_pagetable	proc.c	/^proc_pagetable(struct proc *p)$/;"	f
procdump	proc.c	/^procdump(void)$/;"	f
procinit	proc.c	/^procinit(void)$/;"	f
procstate	proc.h	/^enum procstate { UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
proghdr	elf.h	/^struct proghdr {$/;"	s
pte_t	riscv.h	/^typedef uint64 pte_t;$/;"	t
push_off	spinlock.c	/^push_off(void)$/;"	f
qclass	net.h	/^  uint16 qclass;$/;"	m	struct:dns_question
qdcount	net.h	/^  uint16 qdcount; \/\/ number of question entries$/;"	m	struct:dns
qr	net.h	/^  uint8 qr: 1;  \/\/ query\/response$/;"	m	struct:dns
qtype	net.h	/^  uint16 qtype;$/;"	m	struct:dns_question
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon4	file:
r_mcounteren	riscv.h	/^r_mcounteren()$/;"	f
r_medeleg	riscv.h	/^r_medeleg()$/;"	f
r_mhartid	riscv.h	/^r_mhartid()$/;"	f
r_mideleg	riscv.h	/^r_mideleg()$/;"	f
r_mie	riscv.h	/^r_mie()$/;"	f
r_mstatus	riscv.h	/^r_mstatus()$/;"	f
r_ra	riscv.h	/^r_ra()$/;"	f
r_satp	riscv.h	/^r_satp()$/;"	f
r_scause	riscv.h	/^r_scause()$/;"	f
r_sepc	riscv.h	/^r_sepc()$/;"	f
r_sie	riscv.h	/^r_sie()$/;"	f
r_sip	riscv.h	/^r_sip()$/;"	f
r_sp	riscv.h	/^r_sp()$/;"	f
r_sstatus	riscv.h	/^r_sstatus()$/;"	f
r_stval	riscv.h	/^r_stval()$/;"	f
r_stvec	riscv.h	/^r_stvec()$/;"	f
r_time	riscv.h	/^r_time()$/;"	f
r_tp	riscv.h	/^r_tp()$/;"	f
ra	net.h	/^  uint8 ra: 1;  \/\/ recursion available$/;"	m	struct:dns
ra	proc.h	/^  \/*  40 *\/ uint64 ra;$/;"	m	struct:trapframe
ra	proc.h	/^  uint64 ra;$/;"	m	struct:context
raddr	sysnet.c	/^  uint32 raddr;      \/\/ the remote IPv4 address$/;"	m	struct:sock	file:
ramdiskinit	ramdisk.c	/^ramdiskinit(void)$/;"	f
ramdiskrw	ramdisk.c	/^ramdiskrw(struct buf *b)$/;"	f
rcode	net.h	/^  uint8 rcode: 4; \/\/ response code$/;"	m	struct:dns
rd	net.h	/^  uint8 rd: 1;  \/\/ recursion desired$/;"	m	struct:dns
read	file.h	/^  int (*read)(int, uint64, int);$/;"	m	struct:devsw
read_head	log.c	/^read_head(void)$/;"	f	file:
readable	file.h	/^  char readable;$/;"	m	struct:file
readi	fs.c	/^readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)$/;"	f
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f	file:
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	file:
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
refcnt	buf.h	/^  uint refcnt;$/;"	m	struct:buf
regs	e1000.c	/^static volatile uint32 *regs;$/;"	v	file:
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f
releasesleep	sleeplock.c	/^releasesleep(struct sleeplock *lk)$/;"	f
reparent	proc.c	/^reparent(struct proc *p)$/;"	f
reserved	virtio.h	/^  uint32 reserved;$/;"	m	struct:virtio_blk_req
ring	virtio.h	/^  struct virtq_used_elem ring[NUM];$/;"	m	struct:virtq_used	typeref:struct:virtq_used::virtq_used_elem
ring	virtio.h	/^  uint16 ring[NUM]; \/\/ descriptor numbers of chain heads$/;"	m	struct:virtq_avail
rport	sysnet.c	/^  uint16 rport;      \/\/ the remote UDP port number$/;"	m	struct:sock	file:
rtcdate	date.h	/^struct rtcdate {$/;"	s
run	kalloc.c	/^struct run {$/;"	s	file:
rx_desc	e1000_dev.h	/^struct rx_desc$/;"	s
rx_mbufs	e1000.c	/^static struct mbuf *rx_mbufs[RX_RING_SIZE];$/;"	v	typeref:struct:mbuf	file:
rx_ring	e1000.c	/^static struct rx_desc rx_ring[RX_RING_SIZE] __attribute__((aligned(16)));$/;"	v	typeref:struct:rx_desc	file:
rxq	sysnet.c	/^  struct mbufq rxq;  \/\/ a queue of packets waiting to be received$/;"	m	struct:sock	typeref:struct:sock::mbufq	file:
s0	proc.h	/^  \/*  96 *\/ uint64 s0;$/;"	m	struct:trapframe
s0	proc.h	/^  uint64 s0;$/;"	m	struct:context
s1	proc.h	/^  \/* 104 *\/ uint64 s1;$/;"	m	struct:trapframe
s1	proc.h	/^  uint64 s1;$/;"	m	struct:context
s10	proc.h	/^  \/* 240 *\/ uint64 s10;$/;"	m	struct:trapframe
s10	proc.h	/^  uint64 s10;$/;"	m	struct:context
s11	proc.h	/^  \/* 248 *\/ uint64 s11;$/;"	m	struct:trapframe
s11	proc.h	/^  uint64 s11;$/;"	m	struct:context
s2	proc.h	/^  \/* 176 *\/ uint64 s2;$/;"	m	struct:trapframe
s2	proc.h	/^  uint64 s2;$/;"	m	struct:context
s3	proc.h	/^  \/* 184 *\/ uint64 s3;$/;"	m	struct:trapframe
s3	proc.h	/^  uint64 s3;$/;"	m	struct:context
s4	proc.h	/^  \/* 192 *\/ uint64 s4;$/;"	m	struct:trapframe
s4	proc.h	/^  uint64 s4;$/;"	m	struct:context
s5	proc.h	/^  \/* 200 *\/ uint64 s5;$/;"	m	struct:trapframe
s5	proc.h	/^  uint64 s5;$/;"	m	struct:context
s6	proc.h	/^  \/* 208 *\/ uint64 s6;$/;"	m	struct:trapframe
s6	proc.h	/^  uint64 s6;$/;"	m	struct:context
s7	proc.h	/^  \/* 216 *\/ uint64 s7;$/;"	m	struct:trapframe
s7	proc.h	/^  uint64 s7;$/;"	m	struct:context
s8	proc.h	/^  \/* 224 *\/ uint64 s8;$/;"	m	struct:trapframe
s8	proc.h	/^  uint64 s8;$/;"	m	struct:context
s9	proc.h	/^  \/* 232 *\/ uint64 s9;$/;"	m	struct:trapframe
s9	proc.h	/^  uint64 s9;$/;"	m	struct:context
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sb	fs.c	/^struct superblock sb; $/;"	v	typeref:struct:superblock
sched	proc.c	/^sched(void)$/;"	f
scheduler	proc.c	/^scheduler(void)$/;"	f
second	date.h	/^  uint second;$/;"	m	struct:rtcdate
sector	virtio.h	/^  uint64 sector;$/;"	m	struct:virtio_blk_req
sfence_vma	riscv.h	/^sfence_vma()$/;"	f
sha	net.h	/^  char   sha[ETHADDR_LEN]; \/\/ sender hardware address$/;"	m	struct:arp
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shoff	elf.h	/^  uint64 shoff;$/;"	m	struct:elfhdr
shost	net.h	/^  uint8  shost[ETHADDR_LEN];$/;"	m	struct:eth
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
sip	net.h	/^  uint32 sip;              \/\/ sender IP address$/;"	m	struct:arp
size	file.h	/^  uint size;$/;"	m	struct:inode
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	log.c	/^  int size;$/;"	m	struct:log	file:
size	stat.h	/^  uint64 size; \/\/ Size of file in bytes$/;"	m	struct:stat
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
sleeplock	sleeplock.h	/^struct sleeplock {$/;"	s
snprint_lock	spinlock.c	/^snprint_lock(char *buf, int sz, struct spinlock *lk)$/;"	f
sock	file.h	/^  struct sock *sock; \/\/ FD_SOCK$/;"	m	struct:file	typeref:struct:file::sock
sock	sysnet.c	/^struct sock {$/;"	s	file:
sockalloc	sysnet.c	/^sockalloc(struct file **f, uint32 raddr, uint16 lport, uint16 rport)$/;"	f
sockclose	sysnet.c	/^sockclose(struct sock *si)$/;"	f
sockets	sysnet.c	/^static struct sock *sockets;$/;"	v	typeref:struct:sock	file:
sockinit	sysnet.c	/^sockinit(void)$/;"	f
sockread	sysnet.c	/^sockread(struct sock *si, uint64 addr, int n)$/;"	f
sockrecvudp	sysnet.c	/^sockrecvudp(struct mbuf *m, uint32 raddr, uint16 lport, uint16 rport)$/;"	f
sockwrite	sysnet.c	/^sockwrite(struct sock *si, uint64 addr, int n)$/;"	f
sp	proc.h	/^  \/*  48 *\/ uint64 sp;$/;"	m	struct:trapframe
sp	proc.h	/^  uint64 sp;$/;"	m	struct:context
special	e1000_dev.h	/^  uint16 special;$/;"	m	struct:rx_desc
special	e1000_dev.h	/^  uint16 special;$/;"	m	struct:tx_desc
spin	entry.S	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
sport	net.h	/^  uint16 sport; \/\/ source port$/;"	m	struct:udp
stack0	start.c	/^__attribute__ ((aligned (16))) char stack0[4096 * NCPU];$/;"	v
start	log.c	/^  int start;$/;"	m	struct:log	file:
start	start.c	/^start()$/;"	f
started	main.c	/^volatile static int started = 0;$/;"	v	file:
stat	stat.h	/^struct stat {$/;"	s
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
statslock	spinlock.c	/^statslock(char *buf, int sz) {$/;"	f
status	e1000_dev.h	/^  uint8 status;      \/* Descriptor status *\/$/;"	m	struct:rx_desc
status	e1000_dev.h	/^  uint8 status;$/;"	m	struct:tx_desc
status	virtio_disk.c	/^    char status;$/;"	m	struct:disk::__anon9	file:
strlen	string.c	/^strlen(const char *s)$/;"	f
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
sum	net.h	/^  uint16 sum;   \/\/ checksum$/;"	m	struct:udp
superblock	fs.h	/^struct superblock {$/;"	s
swtch	swtch.S	/^swtch:$/;"	l
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	sysfile.c	/^sys_close(void)$/;"	f
sys_connect	sysfile.c	/^sys_connect(void)$/;"	f
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f
sys_link	sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	sysfile.c	/^sys_open(void)$/;"	f
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f
sys_read	sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f
sys_write	sysfile.c	/^sys_write(void)$/;"	f
syscall	syscall.c	/^syscall(void)$/;"	f
syscalls	syscall.c	/^static uint64 (*syscalls[])(void) = {$/;"	v	file:
sz	proc.h	/^  uint64 sz;                   \/\/ Size of process memory (bytes)$/;"	m	struct:proc
t0	proc.h	/^  \/*  72 *\/ uint64 t0;$/;"	m	struct:trapframe
t1	proc.h	/^  \/*  80 *\/ uint64 t1;$/;"	m	struct:trapframe
t2	proc.h	/^  \/*  88 *\/ uint64 t2;$/;"	m	struct:trapframe
t3	proc.h	/^  \/* 256 *\/ uint64 t3;$/;"	m	struct:trapframe
t4	proc.h	/^  \/* 264 *\/ uint64 t4;$/;"	m	struct:trapframe
t5	proc.h	/^  \/* 272 *\/ uint64 t5;$/;"	m	struct:trapframe
t6	proc.h	/^  \/* 280 *\/ uint64 t6;$/;"	m	struct:trapframe
tail	net.h	/^  struct mbuf *tail;  \/\/ the last element in the queue$/;"	m	struct:mbufq	typeref:struct:mbufq::mbuf
tc	net.h	/^  uint8 tc: 1;  \/\/ truncated$/;"	m	struct:dns
tha	net.h	/^  char   tha[ETHADDR_LEN]; \/\/ target hardware address$/;"	m	struct:arp
ticks	trap.c	/^uint ticks;$/;"	v
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
timer_scratch	start.c	/^uint64 timer_scratch[NCPU][5];$/;"	v
timerinit	start.c	/^timerinit()$/;"	f
timervec	kernelvec.S	/^timervec:$/;"	l
tip	net.h	/^  uint32 tip;              \/\/ target IP address$/;"	m	struct:arp
tp	proc.h	/^  \/*  64 *\/ uint64 tp;$/;"	m	struct:trapframe
trampoline	trampoline.S	/^trampoline:$/;"	l
trapframe	proc.h	/^  struct trapframe *trapframe; \/\/ data page for trampoline.S$/;"	m	struct:proc	typeref:struct:proc::trapframe
trapframe	proc.h	/^struct trapframe {$/;"	s
trapinit	trap.c	/^trapinit(void)$/;"	f
trapinithart	trap.c	/^trapinithart(void)$/;"	f
ttl	net.h	/^  uint32 ttl;$/;"	m	struct:dns_data
tx_desc	e1000_dev.h	/^struct tx_desc$/;"	s
tx_mbufs	e1000.c	/^static struct mbuf *tx_mbufs[TX_RING_SIZE];$/;"	v	typeref:struct:mbuf	file:
tx_ring	e1000.c	/^static struct tx_desc tx_ring[TX_RING_SIZE] __attribute__((aligned(16)));$/;"	v	typeref:struct:tx_desc	file:
type	elf.h	/^  uint32 type;$/;"	m	struct:proghdr
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE, FD_SOCK } type;$/;"	m	struct:file	typeref:enum:file::__anon5
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	net.h	/^  uint16 type;$/;"	m	struct:dns_data
type	net.h	/^  uint16 type;$/;"	m	struct:eth
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
type	virtio.h	/^  uint32 type; \/\/ VIRTIO_BLK_T_IN or ..._OUT$/;"	m	struct:virtio_blk_req
uart_tx_buf	uart.c	/^char uart_tx_buf[UART_TX_BUF_SIZE];$/;"	v
uart_tx_lock	uart.c	/^struct spinlock uart_tx_lock;$/;"	v	typeref:struct:spinlock
uart_tx_r	uart.c	/^uint64 uart_tx_r; \/\/ read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]$/;"	v
uart_tx_w	uart.c	/^uint64 uart_tx_w; \/\/ write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]$/;"	v
uartgetc	uart.c	/^uartgetc(void)$/;"	f
uartinit	uart.c	/^uartinit(void)$/;"	f
uartintr	uart.c	/^uartintr(void)$/;"	f
uartputc	uart.c	/^uartputc(int c)$/;"	f
uartputc_sync	uart.c	/^uartputc_sync(int c)$/;"	f
uartstart	uart.c	/^uartstart()$/;"	f
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
udp	net.h	/^struct udp {$/;"	s
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uint16	types.h	/^typedef unsigned short uint16;$/;"	t
uint32	types.h	/^typedef unsigned int  uint32;$/;"	t
uint64	types.h	/^typedef unsigned long uint64;$/;"	t
uint8	types.h	/^typedef unsigned char uint8;$/;"	t
ulen	net.h	/^  uint16 ulen;  \/\/ length, including udp header, not including IP header$/;"	m	struct:udp
unused	virtio.h	/^  uint16 unused;$/;"	m	struct:virtq_avail
used	virtio_disk.c	/^  struct virtq_used *used;$/;"	m	struct:disk	typeref:struct:disk::virtq_used	file:
used_idx	virtio_disk.c	/^  uint16 used_idx; \/\/ we've looked this far in used[2..NUM].$/;"	m	struct:disk	file:
userinit	proc.c	/^userinit(void)$/;"	f
userret	trampoline.S	/^userret:$/;"	l
usertrap	trap.c	/^usertrap(void)$/;"	f
usertrapret	trap.c	/^usertrapret(void)$/;"	f
uservec	trampoline.S	/^uservec:    $/;"	l
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
usyscall	memlayout.h	/^struct usyscall {$/;"	s
uvmalloc	vm.c	/^uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)$/;"	f
uvmclear	vm.c	/^uvmclear(pagetable_t pagetable, uint64 va)$/;"	f
uvmcopy	vm.c	/^uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)$/;"	f
uvmcreate	vm.c	/^uvmcreate()$/;"	f
uvmdealloc	vm.c	/^uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)$/;"	f
uvmfree	vm.c	/^uvmfree(pagetable_t pagetable, uint64 sz)$/;"	f
uvminit	vm.c	/^uvminit(pagetable_t pagetable, uchar *src, uint sz)$/;"	f
uvmunmap	vm.c	/^uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)$/;"	f
vaddr	elf.h	/^  uint64 vaddr;$/;"	m	struct:proghdr
valid	buf.h	/^  int valid;   \/\/ has data been read from disk?$/;"	m	struct:buf
valid	file.h	/^  int valid;          \/\/ inode has been read from disk?$/;"	m	struct:inode
vdisk_lock	virtio_disk.c	/^  struct spinlock vdisk_lock;$/;"	m	struct:disk	typeref:struct:disk::spinlock	file:
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr
virtio_blk_req	virtio.h	/^struct virtio_blk_req {$/;"	s
virtio_disk_init	virtio_disk.c	/^virtio_disk_init(void)$/;"	f
virtio_disk_intr	virtio_disk.c	/^virtio_disk_intr()$/;"	f
virtio_disk_rw	virtio_disk.c	/^virtio_disk_rw(struct buf *b, int write)$/;"	f
virtq_avail	virtio.h	/^struct virtq_avail {$/;"	s
virtq_desc	virtio.h	/^struct virtq_desc {$/;"	s
virtq_used	virtio.h	/^struct virtq_used {$/;"	s
virtq_used_elem	virtio.h	/^struct virtq_used_elem {$/;"	s
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon4	file:
w_mcounteren	riscv.h	/^w_mcounteren(uint64 x)$/;"	f
w_medeleg	riscv.h	/^w_medeleg(uint64 x)$/;"	f
w_mepc	riscv.h	/^w_mepc(uint64 x)$/;"	f
w_mideleg	riscv.h	/^w_mideleg(uint64 x)$/;"	f
w_mie	riscv.h	/^w_mie(uint64 x)$/;"	f
w_mscratch	riscv.h	/^w_mscratch(uint64 x)$/;"	f
w_mstatus	riscv.h	/^w_mstatus(uint64 x)$/;"	f
w_mtvec	riscv.h	/^w_mtvec(uint64 x)$/;"	f
w_pmpaddr0	riscv.h	/^w_pmpaddr0(uint64 x)$/;"	f
w_pmpcfg0	riscv.h	/^w_pmpcfg0(uint64 x)$/;"	f
w_satp	riscv.h	/^w_satp(uint64 x)$/;"	f
w_sepc	riscv.h	/^w_sepc(uint64 x)$/;"	f
w_sie	riscv.h	/^w_sie(uint64 x)$/;"	f
w_sip	riscv.h	/^w_sip(uint64 x)$/;"	f
w_sscratch	riscv.h	/^w_sscratch(uint64 x)$/;"	f
w_sstatus	riscv.h	/^w_sstatus(uint64 x)$/;"	f
w_stvec	riscv.h	/^w_stvec(uint64 x)$/;"	f
w_tp	riscv.h	/^w_tp(uint64 x)$/;"	f
wait	proc.c	/^wait(uint64 addr)$/;"	f
wait_lock	proc.c	/^struct spinlock wait_lock;$/;"	v	typeref:struct:spinlock
wakeup	proc.c	/^wakeup(void *chan)$/;"	f
walk	vm.c	/^walk(pagetable_t pagetable, uint64 va, int alloc)$/;"	f
walkaddr	vm.c	/^walkaddr(pagetable_t pagetable, uint64 va)$/;"	f
writable	file.h	/^  char writable;$/;"	m	struct:file
write	file.h	/^  int (*write)(int, uint64, int);$/;"	m	struct:devsw
write_head	log.c	/^write_head(void)$/;"	f	file:
write_log	log.c	/^write_log(void)$/;"	f	file:
writei	fs.c	/^writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)$/;"	f
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
xstate	proc.h	/^  int xstate;                  \/\/ Exit status to be returned to parent's wait$/;"	m	struct:proc
year	date.h	/^  uint year;$/;"	m	struct:rtcdate
yield	proc.c	/^yield(void)$/;"	f
z	net.h	/^  uint8 z:  1;  $/;"	m	struct:dns
